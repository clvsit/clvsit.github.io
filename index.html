<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>clvsit 个人博客</title><meta name="author" content="clvsit"><meta name="copyright" content="clvsit"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="人生不是戏剧，而我亦非主角">
<meta property="og:type" content="website">
<meta property="og:title" content="clvsit 个人博客">
<meta property="og:url" content="https://clvsit.github.io/">
<meta property="og:site_name" content="clvsit 个人博客">
<meta property="og:description" content="人生不是戏剧，而我亦非主角">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://clvsit.github.io/img/avatar.jpg">
<meta property="article:author" content="clvsit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://clvsit.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://clvsit.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'clvsit 个人博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-07-06 00:49:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">64</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/banner.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="clvsit 个人博客"><span class="site-name">clvsit 个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">clvsit 个人博客</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/clvsit" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/AI-%E6%83%85%E6%84%9F%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E6%94%B6%E9%9B%86/" title="AI-情感聊天机器人之旅——相关论文收集">AI-情感聊天机器人之旅——相关论文收集</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-20T13:15:26.000Z" title="发表于 2024-06-20 21:15:26">2024-06-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/">业务相关</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E9%97%B2%E8%81%8A%E5%9C%BA%E6%99%AF/">闲聊场景</a></span></div><div class="content">开放域闲聊场景Prompted LLMs as Chatbot Modules for Long Open-domain Conversation

发布日期：2023-05-01

简要介绍：作者提出了 MPC（模块化提示聊天机器人），这是一种无需微调即可创建高质量对话代理的新方法，可以成为长期开放域聊天机器人的有效解决方案。该方法利用预训练好的大型语言模型（LLM）作为单独的模块，通过使用 few-shot、思维链（CoT）和外部记忆等技术来实现长期一致性和灵活性。
  
  MPC 本质上是一种 RAG 或者说 Agent，在输入和输出的中间添加了更多思考和记忆的环节，将 LLM 从“人”的角色进一步拆分为“大脑”和“嘴巴”。这种明确的分工的确能够提升最终的效果，但同样会遇到 RAG、Agent 成本较高的问题，以及引入更多中间环节造成的误差累积。为什么成本较高？为了确保中间环节结果的正确性，往往也会接一个 LLM 去做判断，或者训练专门的小模型，这些都需要资源，并且对整个推理过程的时延造成一定的影响。在业务上是否真得要这么做，还需要进一步衡量效果和成本的 tradeoff。

 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/PyramidKV/" title="PyramidKV">PyramidKV</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-14T12:27:21.000Z" title="发表于 2024-06-14 20:27:21">2024-06-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/">LLM</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/LLM-%E5%8E%8B%E7%BC%A9/">LLM 压缩</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/LLM-%E5%8E%8B%E7%BC%A9/kv-cache-%E5%8E%8B%E7%BC%A9/">kv cache 压缩</a></span></div><div class="content">
论文地址：https://arxiv.org/abs/2406.02069
GitHub 仓库：https://github.com/Zefan-Cai/PyramidKV

北大、威斯康辛-麦迪逊、微软等联合团队提出了全新的缓存分配方案，只用 2.5% 的 kv cache 就能保持大模型 90% 的性能。该方法名为 PyramidKV，在 kv cache 压缩的过程中融入了金字塔型的信息汇聚方式。在内存受限的情况下，PyramidKV 表现非常出色，既保留了长上下文理解能力，又显著减少了内存使用。

传统对 kv cache 压缩的方法有一个共同特点，对每个 Transformer 层的 kv cache“一视同仁”地用相同的压缩设置，压缩到同样的长度。
PyramidKV 团队发现，对 KV cache 进行极致压缩情况下（从 32k 长度压缩到 64，即保留 0.2%的 kv cache）上述方法的表现会面临严重的性能下降。于是作者提出疑问：对每个 Transformer 层将 kv cache 压缩到同样大小是否为最优方案？
研究团队对大模型进行 RAG 的机制进行深入分 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/Long-Context-%E8%B0%83%E7%A0%94/" title="Long Context 调研">Long Context 调研</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-10T14:43:57.000Z" title="发表于 2024-06-10 22:43:57">2024-06-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/">研究方向</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/long-context/">long context</a></span></div><div class="content">

Transformer 架构中的位置编码

上下文外推长期记忆外挂InfLLM
GitHub 仓库：https://github.com/thunlp/InfLLM
论文地址：https://arxiv.org/abs/2402.04617


InfLLM 将遥远的上下文存储到额外的内存单元中，并采用有效的机制来查找与 token 相关的单元以进行注意力计算。因此，InfLLM 允许 LLM 有效地处理长序列，同时保持捕获长距离依赖性的能力。
推理优化减少 kv cache随着模型规模的增大，推理需要的时间越来越多。kv cache 作为推理加速的关键技术，通过缓存之前的解码步骤中计算出的 key_states 和 value_states 来避免在后续解码过程中重复计算，从而减少解码时间（起到空间换时间的作用）。
但是，随着序列长度增大，需要缓存的 kv cache 呈线性增长，占用大量显存。针对这一问题，之前的工作设计策略是调整注意力机制，或者对 kv cache 进行压缩。
调整注意力机制GQA：论文阅读：GQA: Training Generalized Multi-Qu ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/vocab-size-%E7%A0%94%E7%A9%B6/" title="vocab size 调研">vocab size 调研</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-31T15:47:07.000Z" title="发表于 2024-05-31 23:47:07">2024-05-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/NLP/">NLP</a></span></div><div class="content">在 Meta 开源 Llama 模型后，大量的微调模型出现，大部分模型都在 Llama 模型的基础上扩大了词表。例如，01-ai 的 Yi-1.5 将词表大小从 32000 扩展至 64000。
扩大词表的作用：

提高语言覆盖率：扩大词表可以使模型覆盖更多的词汇，特别是包含罕见词汇、专业术语、新词以及多语言环境下的词汇。这对于处理多样化的文本数据，提高模型在特定领域（如医学、法律或多语言环境）的应用效果非常重要。  
减少未知词（OOV）问题：通过增加词表大小，可以减少在文本处理中遇到的未知词（Out-Of-Vocabulary, OOV）问题。这有助于提高模型处理未见过文本的能力，从而在一定程度上提升模型的泛化性能。  
提升模型细粒度：较大的词表使得模型能够识别和生成更加细粒度的文本信息。例如，在生成任务中，模型能够生成更丰富、更精确的文本内容；在理解任务中，模型能更准确地捕捉到文本的细微差别。  
增强多语言和跨文化理解：对于支持多种语言的大型语言模型，扩大词表是必要的，以确保覆盖更广泛的语言和文化。这有助于模型在全球范围内的适用性和灵活性，提升跨语言、跨文化交流的能力。  
 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARCoT-Detecting-and-Rectifying-Factual-Inconsistency-in-Reasoning-by-Reversing-Chain-of-Thought/" title="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/RCoT%EF%BC%9ADetecting%20and%20Rectifying%20Factual%20Inconsistency%20in%20Reasoning%20by%20Reversing%20Chain-of-Thought/Figure%204.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought"></a></div><div class="recent-post-info"><a class="article-title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARCoT-Detecting-and-Rectifying-Factual-Inconsistency-in-Reasoning-by-Reversing-Chain-of-Thought/" title="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought">论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-17T13:37:04.000Z" title="发表于 2024-05-17 21:37:04">2024-05-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/prompt-%E5%B7%A5%E7%A8%8B/">prompt 工程</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/prompt-%E5%B7%A5%E7%A8%8B/CoT-%E5%AE%B6%E6%97%8F/">CoT 家族</a></span></div><div class="content">大语言模型（LLMs）通过结合逐步思维链（step-by-step CoT）提示，在算术推理任务中取得了可喜的成绩。然而，大语言模型在推理过程中保持事实一致性方面面临挑战，在特定问题上表现出条件忽略、问题曲解和条件幻觉的倾向。现有方法使用粗粒度反馈（如答案是否正确）来提高事实一致性。在这项工作中，作者提出了 RCOT（Reverseing Chain-of-Thought），一种通过自动检测和纠正 LLM 生成的解决方案中的事实不一致性来提高 LLM 推理能力的新方法。为了检测事实不一致，RCOT 首先要求 LLM 根据生成的解决方案重建问题。然后，对原始问题和重构问题进行细粒度比较，以发现原始解决方案中的事实不一致之处。为了纠正解决方案，RCoT 将检测到的事实不一致转化为细粒度反馈，以指导 LLM 修订解决方案。
实验结果表明，在七个算术数据集上，RCoT 比标准 CoT 有持续的改进。此外，作者还发现，人工编写的细粒度反馈可以显著提高 LLM 的推理能力（例如，ChatGPT 在 GSM8K 上的准确率达到 94.6%），从而鼓励社区进一步探索细粒度反馈生成方法。
RCoT 方法 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/Transformer-%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/" title="Transformer 架构中的位置编码">Transformer 架构中的位置编码</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-16T06:56:59.000Z" title="发表于 2024-05-16 14:56:59">2024-05-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84/">模型架构</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84/%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/">位置编码</a></span></div><div class="content">Transformer 模型需要位置编码来处理序列数据，因为其核心机制——自注意力（Self-Attention）本身并不具备捕捉序列中元素位置信息的能力。自注意力机制允许模型在计算一个元素的表征时考虑到序列中的所有元素，但是它对这些元素是如何排序的一无所知。这与传统的序列处理模型（如循环神经网络 RNN 和长短期记忆网络 LSTM）不同，后者通过逐个元素的递归处理天然地编码了位置信息。
Transformer 模型的设计理念是完全摒弃递归处理，从而允许并行计算，这极大地提高了训练的效率。然而，这也意味着模型丧失了捕捉序列中位置关系的能力。为了解决这个问题，Transformer 引入了位置编码（Positional Encoding）作为补充信息，确保模型能够利用序列中元素的位置信息。
绝对位置编码绝对位置编码比较简单，研究者一般会将绝对位置信息加到输入中：在输入的第 k 个向量 $x_k$ 中加入位置向量 $p_k$ 得到 $x_k + p_k$，其中 $p_k$ 仅与 k 相关。计算 $p_k$ 的方法一般有两种：

训练式：将位置向量 P 设置为可训练的参数，如 BERT 就将 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/AI-%E6%83%85%E6%84%9F%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E6%97%85-%E2%80%94%E2%80%94-%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%A7%AF%E7%B4%AF/" title="AI 情感聊天机器人之旅 —— 多轮对话存在的问题与数据积累">AI 情感聊天机器人之旅 —— 多轮对话存在的问题与数据积累</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-14T03:39:31.000Z" title="发表于 2024-05-14 11:39:31">2024-05-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/">业务相关</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E9%97%B2%E8%81%8A%E5%9C%BA%E6%99%AF/">闲聊场景</a></span></div><div class="content">在 QA、逻辑推理等领域，多跳问答比单跳问答难得多。在聊天机器人场景中亦是如此，模型需要结合历史对话和用户当前的输入内容生成合适的响应。然而，现有的指令数据大都是单轮或者两轮的对话（截止这篇文章落笔的日期 2023-09-10），模型在对话轮数较少时，还能很好地遵循指令、记住历史信息以及输出合适的内容。但对话轮数多了后，模型的输出往往会变得不可控，例如越来越长、格式出现错误、遗忘历史信息、指令遵循能力变弱（人设不符）。一方面是因为上下文变长、加上 Lost in the middle 等 prompt 层面的影响；另一方面是模型在多轮对话下的对齐能力较弱（多轮对话数据的训练数据质量较差，且在 long context 场景下“锻炼”得不够）。
在处理多跳问题和数学推理等较难任务时，除了在模型层面做优化外，往往会使用 CoT 系列的 prompt 工程，例如“Let’s think step by step”的方式。我理解它们能提升 LLM 推理能力的一部分原因在于将任务拆解，输出中间步骤，对于从左到右的生成式模型来说，这些补齐的中间步骤的生成为输入空间带来了更细致的条件约束，而这些条件 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/AI-%E6%83%85%E6%84%9F%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E4%BD%9C%E4%B9%8B%E6%97%85-%E2%80%94%E2%80%94-%E4%B8%8E%E5%A4%8D%E8%AF%BB%E6%9C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E7%9B%B8%E9%81%87%E4%B8%8E%E5%88%AB%E7%A6%BB/" title="AI 情感聊天机器人工作之旅 —— 与复读机问题的相遇与别离"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/task/%E5%A4%8D%E8%AF%BB%E6%9C%BA%E9%97%AE%E9%A2%98/%E5%A4%8D%E8%AF%BB%E6%9C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 情感聊天机器人工作之旅 —— 与复读机问题的相遇与别离"></a></div><div class="recent-post-info"><a class="article-title" href="/AI-%E6%83%85%E6%84%9F%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E4%BD%9C%E4%B9%8B%E6%97%85-%E2%80%94%E2%80%94-%E4%B8%8E%E5%A4%8D%E8%AF%BB%E6%9C%BA%E9%97%AE%E9%A2%98%E7%9A%84%E7%9B%B8%E9%81%87%E4%B8%8E%E5%88%AB%E7%A6%BB/" title="AI 情感聊天机器人工作之旅 —— 与复读机问题的相遇与别离">AI 情感聊天机器人工作之旅 —— 与复读机问题的相遇与别离</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-13T15:29:22.000Z" title="发表于 2024-05-13 23:29:22">2024-05-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/">业务相关</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E7%9B%B8%E5%85%B3/%E9%97%B2%E8%81%8A%E5%9C%BA%E6%99%AF/">闲聊场景</a></span></div><div class="content">前言：先前在杭州的一家大模型公司从事海外闲聊机器人产品，目前已经离职，文章主要讨论在闲聊场景下遇到的“复读机”问题以及一些我个人的思考和解决方案。文章内部已经对相关公司和人员信息做了去敏，如仍涉及到机密等情况，可删除。
meta 开源 Llama2 后，我们立马将基座模型从 Llama1 更换为了 Llama2。很重要的一个原因在于 Llama2 的 context length 是 4k，是 Llama1 的 2 倍，对于日益增长的角色人设 prompt 来说，2k 已经不满足线上产品使用。
在将 base 模型从 Llama1 “升级”到 Llama2 后出现了单句重复问题，该问题也被业界定义为“复读机问题”——模型会在一轮回复中不断重复某一相同或语义相似的子句，直到 max_new_tokens（最大输出长度）。

PS：Llama1 有没有这个问题已经无法追溯，其一，当时还没有在 sentry 查看日志链路的习惯；其二，产品和社区没有反馈该类问题，产品妹子们更多地是反馈多轮重复问题——模型在多轮对话中重复相同的内容。

由于当时尚处于 8 月份，vLLM 框架的集成以及后续将部 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ASelf-Evolved-Diverse-Data-Sampling-for-Efficient-Instruction-Tuning-%E6%95%B0%E6%8D%AE%E5%AD%90%E9%9B%86%E6%8C%91%E9%80%89%E6%96%B9%E6%B3%95/" title="论文阅读：Self-Evolved Diverse Data Sampling for Efficient Instruction Tuning 数据子集挑选方法"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/Self-Evolved%20Diverse%20Data%20Sampling%20for%20Efficient%20Instruction%20Tuning/Figure%201.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：Self-Evolved Diverse Data Sampling for Efficient Instruction Tuning 数据子集挑选方法"></a></div><div class="recent-post-info"><a class="article-title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ASelf-Evolved-Diverse-Data-Sampling-for-Efficient-Instruction-Tuning-%E6%95%B0%E6%8D%AE%E5%AD%90%E9%9B%86%E6%8C%91%E9%80%89%E6%96%B9%E6%B3%95/" title="论文阅读：Self-Evolved Diverse Data Sampling for Efficient Instruction Tuning 数据子集挑选方法">论文阅读：Self-Evolved Diverse Data Sampling for Efficient Instruction Tuning 数据子集挑选方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-12T15:31:34.000Z" title="发表于 2024-05-12 23:31:34">2024-05-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/">LLM</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/">数据增强</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/%E6%95%B0%E6%8D%AE%E5%AD%90%E9%9B%86%E6%8C%91%E9%80%89/">数据子集挑选</a></span></div><div class="content">论文链接：https://arxiv.org/abs/2202.06417
GitHub 仓库：https://github.com/OFA-Sys/DiverseEvol
提高大型语言模型（LLM）的指令遵循能力主要需要大量的指令调整数据集。然而，这些数据集的庞大数量带来了相当大的计算负担和标注成本。为了研究一种标注效率高的指令调整方法，使模型本身能够主动采样同样有效甚至更有效的子集，作者引入了一种自进化机制 DIVERSEEVOL。在这一过程中，模型会反复增强其训练子集，以完善自身性能，而无需人类或更高级 LLM 的干预。该数据采样技术的关键在于提高所选子集的多样性，因为模型会根据其当前的嵌入空间选择与任何现有数据点最不同的新数据点。三个数据集和基准的广泛实验证明了 DIVERSEEVOL 的有效性。与在全部数据上进行微调相比，在不到 8% 的原始数据集上训练的模型保持或提高了性能。作者还提供了经验证据来分析指令数据多样性的重要性，以及迭代方案相对于一次性采样的重要性。
方法：DIVERSEEVOL迭代指令数据选择目标是将指令数据挖掘正规化，使其成为一个迭代过程，按照一定的策略从庞 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E5%B1%82%E5%89%AA%E6%9E%9D%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%AB%81%E6%8E%A5%E7%9A%84%E2%80%9C%E5%8F%8C%E7%94%9F%E8%8A%B1%E2%80%9D/" title="论文阅读：The Unreasonable Ineffectiveness of the Deeper Layers 层剪枝与模型嫁接的“双生花”"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/The%20Unreasonable%20Ineffectiveness%20of%20the%20Deeper%20Layers/Figure%201.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：The Unreasonable Ineffectiveness of the Deeper Layers 层剪枝与模型嫁接的“双生花”"></a></div><div class="recent-post-info"><a class="article-title" href="/%E5%B1%82%E5%89%AA%E6%9E%9D%E4%B8%8E%E6%A8%A1%E5%9E%8B%E5%AB%81%E6%8E%A5%E7%9A%84%E2%80%9C%E5%8F%8C%E7%94%9F%E8%8A%B1%E2%80%9D/" title="论文阅读：The Unreasonable Ineffectiveness of the Deeper Layers 层剪枝与模型嫁接的“双生花”">论文阅读：The Unreasonable Ineffectiveness of the Deeper Layers 层剪枝与模型嫁接的“双生花”</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-10T14:06:15.000Z" title="发表于 2024-05-10 22:06:15">2024-05-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/">LLM</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/LLM/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D/">模型剪枝</a></span></div><div class="content">作者实证研究了针对流行的开放式预训练 LLM 系列的简单层修剪策略，发现在不同的 QA 基准上，直到去掉一大部分（最多一半）层（Transformer 架构）后，性能的下降才会降到最低。为了修剪这些模型，作者通过考虑各层之间的相似性来确定要修剪的最佳层；然后，为了“治愈”损伤，进行了少量的微调。特别是 PEFT 方法，尤其是量化和低秩适配器（QLoRA），这样每个实验都可以在单张 A100 GPU 上完成。
从实用的角度来看，这些结果表明，层剪枝方法一方面可以补充其他 PEFT 策略，进一步减少微调的计算资源，另一方面可以改善推理的显存开销和生成时延。从科学角度看，这些 LLM 对层删除的鲁棒性意味着，要么当前的预训练方法没有正确利用网络深层的参数，要么浅层在存储知识方面起着关键作用。
方法作者在论文中写道：移除层的直觉来自于将表征视为层索引的缓慢变化函数，特别是 transformer 层与层之间的表征变化由一个残差迭代方程给出：$$x^{(l + 1)} &#x3D; x^{(l)} + f(x^{(l)}, \theta^{(l)})$$
注意：现在的 LLM 大都是 pre-n ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARHO-1%EF%BC%9ANot-All-Tokens-Are-What-You-Need-%E9%80%89%E6%8B%A9%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84-Tokens-%E5%8F%82%E4%B8%8E%E8%AE%AD%E7%BB%83/" title="论文阅读：RHO-1：Not All Tokens Are What You Need 选择你需要的 Tokens 参与训练"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/RHO-1%20Not%20All%20Tokens%20Are%20What%20You%20Need/Figure%202.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：RHO-1：Not All Tokens Are What You Need 选择你需要的 Tokens 参与训练"></a></div><div class="recent-post-info"><a class="article-title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARHO-1%EF%BC%9ANot-All-Tokens-Are-What-You-Need-%E9%80%89%E6%8B%A9%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84-Tokens-%E5%8F%82%E4%B8%8E%E8%AE%AD%E7%BB%83/" title="论文阅读：RHO-1：Not All Tokens Are What You Need 选择你需要的 Tokens 参与训练">论文阅读：RHO-1：Not All Tokens Are What You Need 选择你需要的 Tokens 参与训练</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-05T08:39:37.000Z" title="发表于 2024-05-05 16:39:37">2024-05-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">模型训练</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/pretrain/">pretrain</a></span></div><div class="content">论文链接：https://arxiv.org/abs/2404.07965
以往的语言模型预训练方法对所有训练 token 统一采用 next-token 预测损失。作者认为“并非语料库中的所有 token 对语言模型训练都同样重要”，这是对这一规范的挑战。作者的初步分析深入研究了语言模型的 token 级训练动态，揭示了不同 token 的不同损失模式。利用这些见解，推出了一种名为 RHO-1 的新语言模型。与学习预测语料库中 next-token 的传统 LM 不同，RHO-1 采用了选择性语言建模 (SLM)，即有选择地对符合预期分布的有用 token 进行训练。这种方法包括使用参考模型对预训练 token 进行评分，然后对超额损失较高的 token 进行有针对性损失的语言模型训练。
在 15B OpenWebMath 语料库上进行持续预训练时，RHO-1 在 9 项数学任务中获得了高达 30% 的 few-shot 准确率绝对提升。经过微调后，RHO-1-1B 和 7B 在 MATH 数据集上分别取得了 40.6% 和 51.8% 的一流结果——仅用 3% 的预训练 token ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E3%80%8ASequence-can-Secretly-Tell-You-What-to-Discard%E3%80%8B%EF%BC%8C%E5%87%8F%E5%B0%91%E6%8E%A8%E7%90%86%E9%98%B6%E6%AE%B5%E7%9A%84-kv-cache/" title="论文阅读：《Sequence can Secretly Tell You What to Discard》，减少推理阶段的 kv cache"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/Sequence%20can%20Secretly%20Tell%20You%20What%20to%20Discard/Figure%202.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：《Sequence can Secretly Tell You What to Discard》，减少推理阶段的 kv cache"></a></div><div class="recent-post-info"><a class="article-title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9A%E3%80%8ASequence-can-Secretly-Tell-You-What-to-Discard%E3%80%8B%EF%BC%8C%E5%87%8F%E5%B0%91%E6%8E%A8%E7%90%86%E9%98%B6%E6%AE%B5%E7%9A%84-kv-cache/" title="论文阅读：《Sequence can Secretly Tell You What to Discard》，减少推理阶段的 kv cache">论文阅读：《Sequence can Secretly Tell You What to Discard》，减少推理阶段的 kv cache</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-04T11:50:09.000Z" title="发表于 2024-05-04 19:50:09">2024-05-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/">推理加速</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/kv-cache/">kv cache</a></span></div><div class="content">目前各类大模型都支持长文本，例如 kimi chat 以及 gemini pro，都支持 100K 以及更高的上下文长度。但越长的上下文，在推理过程中需要存储的 kv cache 也越多。假设，数据的批次用 b 表示，输入序列的长度仍然用 s 表示，输出序列的长度用 n 表示，隐藏层维度用 h 表示，层数用 l 表示。kv cache 的峰值显存占用大小 &#x3D; $b * (s + n) * h * l * 2 * 2 &#x3D; 4blh(s + n)$，这里的第一个 2 表示 k 和 v cache，第二个 2 表示 float16 数据格式存储 kv cache，每个元素占 2 bytes。
然而，目前的大多数 LLM 会使用 GQA 而非 MHA，因此 kv cache 的占用量会更少，以 transformers 的 modeling_llama.py 脚本中的实现为例：
123456789101112131415161718192021class LlamaAttention(nn.Module):    def __init__(self, config: Lla ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ALeave-No-Context-Behind-Efficient-Infinite-Context-Transformers-with-Infini-attention/" title="论文阅读：Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/Leave%20No%20Context%20Behind%20Efficient%20Infinite%20Context%20Transformers%20with%20Infini-attention/Figure%202.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention"></a></div><div class="recent-post-info"><a class="article-title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ALeave-No-Context-Behind-Efficient-Infinite-Context-Transformers-with-Infini-attention/" title="论文阅读：Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention">论文阅读：Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-30T14:57:25.000Z" title="发表于 2024-04-30 22:57:25">2024-04-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/">研究方向</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/long-context/">long context</a></span></div><div class="content">这项研究介绍了一种高效的方法，可将基于 Transformer 的大型语言模型（LLM）扩展到无限长的输入，同时限制内存和计算量。该方法的一个关键组成部分是一种新的注意力技术，被称为 Infini-attention。Infini-attention 在 vanilla 注意力机制中加入了压缩内存，并在单个 Transformer 块中建立了掩码局部注意和长期线性注意机制。
作者使用 1B 和 8B LLM，在长上下文语言建模基准、1M 序列长度的 passkey context block 检索和 500K 长度的书籍摘要任务中展示了该方法的有效性。该方法引入了最小的有界内存参数，实现了 LLM 的快速流推理。
方法图 2 比较了提出的模型、Infini-Transformer 和 Transformer-XL。与 Transformer-XL 类似，Infini-Transformer 也是在一个片段序列上运行。作者在每个片段中计算标准的因果点积注意力上下文。因此，点积注意力计算是局部的，即它覆盖了当前片段中索引为 S 的 N 个 token（N 为片段长度）。然而，局部注意力（D ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/FlashAttention-V1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="FlashAttention V1 学习笔记"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/dl/Attention/FlashAttentionV1/tiling%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81softmax%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FlashAttention V1 学习笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/FlashAttention-V1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="FlashAttention V1 学习笔记">FlashAttention V1 学习笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-10T14:27:53.000Z" title="发表于 2024-04-10 22:27:53">2024-04-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84/">模型架构</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">注意力机制</a></span></div><div class="content">
博客的数学公式显示有些许问题，更佳的阅读体验请参阅 https://www.wolai.com/voY74vy53rt6bwrMBzEDDU 。

Flash Attention 是一种新型的注意力机制，旨在解决传统 Transformer 模型在处理长序列数据时面临的计算和内存效率问题。它通过一系列创新的技术优化，显著提高了注意力机制的计算速度和内存使用效率，同时保持了精确的结果，不依赖于近似计算。
背景&amp;动机当输入序列较长时，Transformer 的计算过程缓慢且耗费内存，这是因为 self-attention 的时间和内存复杂度会随着序列长度的增加而呈二次增长。标准 Attention 计算的中间结果 S, P（见下文）通常需要通过 HBM 进行存取，两者所需内存空间复杂度为$O(N^2)$。
$$self-attention(x) &#x3D; softmax(\frac{Q K^T}{\sqrt{d}})\cdot V$$
$$S &#x3D; \frac{Q K^T}{\sqrt{d}}, \quad P &#x3D; softmax(S)$$
在不考虑 bat ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/ConvRAG%EF%BC%9A%E9%80%9A%E8%BF%87%E7%BB%86%E7%B2%92%E5%BA%A6%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E5%92%8C%E8%87%AA%E6%88%91%E6%A3%80%E6%9F%A5%E6%8F%90%E5%8D%87%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%AF%9D%E5%BC%8F%E9%97%AE%E7%AD%94%E8%83%BD%E5%8A%9B/" title="ConvRAG：通过细粒度检索增强和自我检查提升大模型对话式问答能力"><img class="post-bg" src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/Boosting%20Conversational%20Question%20Answering%20with%20Fine-Grained%20Retrieval%20Augmentation%20and%20Self-Check/Figure%201.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConvRAG：通过细粒度检索增强和自我检查提升大模型对话式问答能力"></a></div><div class="recent-post-info"><a class="article-title" href="/ConvRAG%EF%BC%9A%E9%80%9A%E8%BF%87%E7%BB%86%E7%B2%92%E5%BA%A6%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E5%92%8C%E8%87%AA%E6%88%91%E6%A3%80%E6%9F%A5%E6%8F%90%E5%8D%87%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%AF%9D%E5%BC%8F%E9%97%AE%E7%AD%94%E8%83%BD%E5%8A%9B/" title="ConvRAG：通过细粒度检索增强和自我检查提升大模型对话式问答能力">ConvRAG：通过细粒度检索增强和自我检查提升大模型对话式问答能力</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-10T07:23:56.000Z" title="发表于 2024-04-10 15:23:56">2024-04-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/RAG/">RAG</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/RAG/%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2/">查询检索</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/RAG/%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2/%E6%A3%80%E7%B4%A2%E7%8E%AF%E8%8A%82/">检索环节</a></span></div><div class="content">
论文地址：https://arxiv.org/pdf/2403.18243.pdf
文章链接：https://mp.weixin.qq.com/s/InjLKF8lepX6hfi6W-oeMQ

ConvRAG 是一种对话式问答方法，通过细粒度检索增强和自我检查机制提升 LLM 在对话环境中的问题理解和信息获取能力。
文章介绍了一种名为 ConvRAG 的新型对话式问答方法，旨在增强 LLMs 的对话问答能力。ConvRAG 通过结合细粒度检索增强和自我检查机制，解决了以往 RAG 方法在单轮问答中的局限性，并将其成功适应于复杂的对话环境（问题与之前的上下文相互依赖）。

ConvRAG 的核心在于三个关键组件的协同工作：

对话式问题精炼器：通过问题重构和关键词提取，使问题意图更加明确，以便更好地理解与上下文相关联的问题。
细粒度检索器：利用问题重构和关键词从网络中检索最相关的信息，以支持响应生成。检索过程包括文档级检索、段落级召回和段落级重排，以确保获取到最有用的信息片段。
基于自我检查的响应生成器：在生成响应之前，先对检索到的信息进行自我检查，以确保使用的是有用的信息，从而提高 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="硬件相关知识">硬件相关知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-09T07:50:17.000Z" title="发表于 2024-04-09 15:50:17">2024-04-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/">硬件相关</a></span></div><div class="content">
显卡

存储体系寄存器寄存器是处理器内部非常小但极其快速的存储单元，直接嵌入在CPU核心中。它们用于存储指令、数据和地址信息，是CPU执行指令时最先访问的存储区域。寄存器的数量相对有限，但访问速度极快，几乎与CPU的运算速度一致。由于寄存器的数量和大小都很有限，它们主要用于存储当前指令执行中最为关键的数据。  
片上缓存  （on-chip cache）片上缓存是一种位于 CPU 内部的 Cache（缓存）。在计算机架构中，Cache 是指一种快速的存储层，目的是存储临时指令和数据，以便于快速访问。这样 CPU 在执行任务时可以迅速获取这些信息，而不需要每次都去较慢的主内存（RAM）中读取数据。
片上缓存的主要目的是通过在CPU和主内存之间提供一个高速的临时存储区域来减少CPU访问主内存所需的时间。这种缓存通常分为几个层级（如L1、L2、L3），每个层级的大小和速度都有所不同。

L1缓存：它是最接近CPU核心的缓存，也是速度最快的缓存，但通常容量较小。L1缓存通常分为两个部分：一个用于存储指令（I-Cache），另一个用于存储数据（D-Cache）。  
L2缓存：它的速度比L1慢 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/#content-inner">6</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">clvsit</div><div class="author-info__description">人生不是戏剧，而我亦非主角</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">64</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/clvsit"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/clvsit" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">知乎和 CSDN 同名 clvsit，目前在将本地的笔记逐步迁移到这，所以会看到过去日期的文章不断增多</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI-%E6%83%85%E6%84%9F%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E6%94%B6%E9%9B%86/" title="AI-情感聊天机器人之旅——相关论文收集">AI-情感聊天机器人之旅——相关论文收集</a><time datetime="2024-06-20T13:15:26.000Z" title="发表于 2024-06-20 21:15:26">2024-06-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/PyramidKV/" title="PyramidKV">PyramidKV</a><time datetime="2024-06-14T12:27:21.000Z" title="发表于 2024-06-14 20:27:21">2024-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Long-Context-%E8%B0%83%E7%A0%94/" title="Long Context 调研">Long Context 调研</a><time datetime="2024-06-10T14:43:57.000Z" title="发表于 2024-06-10 22:43:57">2024-06-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/vocab-size-%E7%A0%94%E7%A9%B6/" title="vocab size 调研">vocab size 调研</a><time datetime="2024-05-31T15:47:07.000Z" title="发表于 2024-05-31 23:47:07">2024-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARCoT-Detecting-and-Rectifying-Factual-Inconsistency-in-Reasoning-by-Reversing-Chain-of-Thought/" title="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought"><img src="https://markdown-picture-clvsit.oss-cn-hangzhou.aliyuncs.com/nlp/paper/RCoT%EF%BC%9ADetecting%20and%20Rectifying%20Factual%20Inconsistency%20in%20Reasoning%20by%20Reversing%20Chain-of-Thought/Figure%204.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought"/></a><div class="content"><a class="title" href="/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%9ARCoT-Detecting-and-Rectifying-Factual-Inconsistency-in-Reasoning-by-Reversing-Chain-of-Thought/" title="论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought">论文阅读：RCoT Detecting and Rectifying Factual Inconsistency in Reasoning by Reversing Chain-of-Thought</a><time datetime="2024-05-17T13:37:04.000Z" title="发表于 2024-05-17 21:37:04">2024-05-17</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/"><span class="card-category-list-name">LLM</span><span class="card-category-list-count">12</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/LLM-%E5%8E%8B%E7%BC%A9/"><span class="card-category-list-name">LLM 压缩</span><span class="card-category-list-count">1</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/LLM-%E5%8E%8B%E7%BC%A9/kv-cache-%E5%8E%8B%E7%BC%A9/"><span class="card-category-list-name">kv cache 压缩</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/SFT/"><span class="card-category-list-name">SFT</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/%E6%8E%A8%E7%90%86%E7%9B%B8%E5%85%B3/"><span class="card-category-list-name">推理相关</span><span class="card-category-list-count">4</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/%E6%8E%A8%E7%90%86%E7%9B%B8%E5%85%B3/%E6%8E%A8%E7%90%86%E6%9C%8D%E5%8A%A1/"><span class="card-category-list-name">推理服务</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/%E6%8E%A8%E7%90%86%E7%9B%B8%E5%85%B3/%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/"><span class="card-category-list-name">推理框架</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/LLM/%E6%8E%A8%E7%90%86%E7%9B%B8%E5%85%B3/%E6%98%BE%E5%8D%A1%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%84/"><span class="card-category-list-name">显卡性能测评</span><span class="card-category-list-count">1</span></a></li></ul></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/" style="font-size: 1.1em; color: #999">层次聚类</a> <a href="/tags/%E5%AD%90%E8%AF%8D%E6%A8%A1%E5%9E%8B/" style="font-size: 1.1em; color: #999">子词模型</a> <a href="/tags/LLM-%E6%8E%A8%E7%90%86%E7%9B%B8%E5%85%B3/" style="font-size: 1.18em; color: #999ca1">LLM 推理相关</a> <a href="/tags/%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/" style="font-size: 1.1em; color: #999">推理框架</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E8%A1%8C%E8%AE%AD%E7%BB%83/" style="font-size: 1.1em; color: #999">分布式并行训练</a> <a href="/tags/kv-cache-%E5%8E%8B%E7%BC%A9/" style="font-size: 1.1em; color: #999">kv cache 压缩</a> <a href="/tags/vLLM-%E6%A1%86%E6%9E%B6/" style="font-size: 1.18em; color: #999ca1">vLLM 框架</a> <a href="/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/" style="font-size: 1.18em; color: #999ca1">注意力机制</a> <a href="/tags/%E6%8F%90%E5%89%8D%E9%80%80%E5%87%BA/" style="font-size: 1.18em; color: #999ca1">提前退出</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%90%E9%9B%86%E6%8C%91%E9%80%89/" style="font-size: 1.1em; color: #999">数据子集挑选</a> <a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.18em; color: #999ca1">硬件</a> <a href="/tags/%E9%87%8D%E6%8E%92/" style="font-size: 1.1em; color: #999">重排</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/" style="font-size: 1.18em; color: #999ca1">数据增强</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9/" style="font-size: 1.26em; color: #999fa8">工作内容</a> <a href="/tags/prompt-%E5%B7%A5%E7%A8%8B/" style="font-size: 1.34em; color: #99a3b0">prompt 工程</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/" style="font-size: 1.18em; color: #999ca1">知识蒸馏</a> <a href="/tags/%E8%A7%A3%E7%A0%81%E7%AD%96%E7%95%A5/" style="font-size: 1.1em; color: #999">解码策略</a> <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 1.5em; color: #99a9bf">论文阅读</a> <a href="/tags/%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/" style="font-size: 1.26em; color: #999fa8">位置编码</a> <a href="/tags/long-context/" style="font-size: 1.26em; color: #999fa8">long context</a> <a href="/tags/%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2/" style="font-size: 1.1em; color: #999">混合检索</a> <a href="/tags/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA/" style="font-size: 1.1em; color: #999">检索增强</a> <a href="/tags/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/" style="font-size: 1.1em; color: #999">文本分类</a> <a href="/tags/%E5%B9%BB%E8%A7%89%E9%97%AE%E9%A2%98/" style="font-size: 1.1em; color: #999">幻觉问题</a> <a href="/tags/%E6%9F%A5%E8%AF%A2%E5%8F%98%E6%8D%A2/" style="font-size: 1.1em; color: #999">查询变换</a> <a href="/tags/%E6%8E%A8%E7%90%86%E5%8A%A0%E9%80%9F/" style="font-size: 1.1em; color: #999">推理加速</a> <a href="/tags/prompt-%E5%8E%8B%E7%BC%A9/" style="font-size: 1.1em; color: #999">prompt 压缩</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%9E%84%E9%80%A0/" style="font-size: 1.1em; color: #999">数据构造</a> <a href="/tags/%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%AD%98%E5%88%86%E6%9E%90/" style="font-size: 1.1em; color: #999">参数与显存分析</a> <a href="/tags/RAG/" style="font-size: 1.42em; color: #99a6b7">RAG</a> <a href="/tags/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" style="font-size: 1.26em; color: #999fa8">预训练模型</a> <a href="/tags/LLM-%E6%8E%A8%E7%90%86%E6%9C%8D%E5%8A%A1/" style="font-size: 1.1em; color: #999">LLM 推理服务</a> <a href="/tags/%E8%B0%83%E7%A0%94/" style="font-size: 1.1em; color: #999">调研</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">9</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><span class="card-archive-list-count">9</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">81</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">219.6k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-07-05T16:49:16.560Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/banner.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By clvsit</div><div class="footer_custom_text">城南芳草城北溪，池塘烟柳归鸟栖。忽听窗外风吹雨，一梦花落月近西。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js@2.1.0/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  if (true) {
    typedJSFn.init("sadasd")
  } else {
    document.getElementById("subtitle").textContent = "s"
  }
}
typedJSFn.run(subtitleType)</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>